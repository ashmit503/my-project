NAME-Ashmit Thakur
UID-23BAI70503
SECTION-23AML-7 A


EXPERIMENT-15



The main goal of this code is to create a RESTful API for managing an e-commerce product catalog, where each product can have multiple variants (such as color, size, and stock).

Hereâ€™s a detailed breakdown of how the code works:

A. Project Structure and Setup

Express.js is used to create the server and define API endpoints.
Mongoose is used to define schemas and models for MongoDB collections, making it easier to interact with the database using JavaScript objects.
dotenv is used to manage environment variables, such as the MongoDB connection string and server port.
Morgan and CORS are included for logging HTTP requests and enabling cross-origin requests, respectively.

B. Product Model and Schema

The Product model is defined with fields: name, price, category, and an array of variants.
Each variant is a subdocument with color, size, and stock fields.
This nested structure allows each product to have multiple options (e.g., a T-shirt in different colors and sizes).

C. API Endpoints

The API exposes several endpoints for interacting with the product catalog
POST /api/products/seed: Deletes all existing products and inserts a set of sample products. This is useful for quickly populating the database with test data.
GET /api/products/: Retrieves all products from the database.
GET /api/products/category/:category: Retrieves all products that belong to a specific category (e.g., Clothing, Electronics)
GET /api/products/variant/:color: Retrieves products that have at least one variant with the specified color. Only the matching variant(s) are returned for each product.
Each endpoint uses Mongoose methods like find, insertMany, and deleteMany to interact with the MongoDB database. The code is organized using Express routers, making it modular and easy to maintain.

D. Error Handling and Best Practices

The code should ideally wrap database operations in try-catch blocks to handle errors gracefully and return meaningful error messages to the client.
Environment variables are used for sensitive information, keeping the codebase secure and flexible.
The use of modular routers (productsRouter) keeps the code organized and scalable.


2. Postman: API Testing and Usage

Postman is a popular tool for testing and interacting with APIs. It allows developers to simulate HTTP requests (GET, POST, PUT, DELETE, etc.) to their API endpoints and view the responses, making it easier to debug and verify backend functionality.

A. Why Use Postman?

Simulate all types of HTTP requests (not just GET, but also POST, PUT, DELETE, etc.), which is difficult to do from a browser alone.
View and debug responses from your API, including status codes, headers, and JSON data.
Save and organize requests for repeated testing and collaboration.
Automate testing by chaining requests and validating responses.

B. How to Use Postman with This API

1. Seeding the Database

Method: POST
URL: http://localhost:3000/api/products/seed
Body: No body needed
Purpose: Populates the database with sample products. This is usually the first step after starting your server.
Expected Response: A JSON array of the inserted products.

2. Retrieving All Products

Method: GET
URL: http://localhost:3000/api/products/
Purpose: Fetches all products in the database.
Expected Response: A JSON array of all product documents.

3. Filtering by Category

Method: GET
URL: http://localhost:3000/api/products/category/Clothing (replace Clothing with any category)
Purpose: Fetches products that belong to a specific category.
Expected Response: A JSON array of products in that category.

4. Filtering by Variant Color

Method: GET
URL: http://localhost:3000/api/products/variant/Red (replace Red with any color)
Purpose: Fetches products that have at least one variant with the specified color. Only the matching variant(s) are returned for each product.
Expected Response: A JSON array of products with the specified color variant.

C. Step-by-Step Example Using Postman

Start your Node.js server (e.g., node server.js).
Open Postman and create a new request.
Set the HTTP method (GET or POST) and enter the appropriate URL.
For POST requests, ensure the body is set to raw and JSON if needed (for the seed endpoint, no body is required).
Click Send and observethe response in the lower panel.
Check the status code (200 for success, 404 for not found, 500 for server error, etc.).
Review the JSON response to verify the data returned matches your expectations.

D. Common Postman Features for API Testing

Collections: Group related requests for easy access and sharing.
Environments: Store variables like base URLs or API keys for different setups (development, production, etc.).
Tests: Write scripts to automatically check response data and status codes.
History: View and repeat previous requests.

E. Best Practices for API Testing with Postman

Seed your database before running tests to ensure consistent data.
Test all endpoints (including edge cases, such as non-existent categories or colors).
Validate responses for correct structure and data types.
Handle errors gracefully and check for meaningful error messages.

F. Output screenshots are present in the ouptut_screenshots folder 

3. Summary

The provided code creates a RESTful API for an e-commerce catalog using Express.js and MongoDB, with endpoints for seeding, retrieving, and filtering products.
Postman is an essential tool for testing these endpoints, allowing you to simulate requests, view responses, and debug your API without needing a frontend.
By following best practices in both code organization and API testing, you ensure your backend is robust, maintainable, and ready for integration with frontend applications or third-party services.
